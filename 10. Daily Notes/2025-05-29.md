---
date: 2025-05-29
tags:
  - daily
created: 2025-05-29T14:37
updated: 2025-05-29T23:27
---
1. **통합 설계 및 개발 계획서 (v1.0 또는 최신 버전):**
    
    - **가장 중요한 문서입니다.** 여기에는 프로젝트의 전반적인 목표, 기술 스택, 그리고 가장 중요하게는 **아래에 언급될 모든 핵심 정보들이 요약 또는 상세하게 포함**되어 있어야 합니다.
        
    - 각 LLM은 자신이 담당하는 부분 외에도 다른 컴포넌트가 어떤 역할을 하는지, 전체 시스템이 어떻게 구성되는지에 대한 큰 그림을 이해해야 합니다.
        
2. **데이터베이스 스키마 (MySQL):**
    
    - **테이블 구조:** 모든 테이블명, 컬럼명, 데이터 타입, 제약 조건(PK, FK, Unique, Not Null 등), 인덱스.
        
    - **테이블 간의 관계:** 어떤 테이블이 어떤 테이블을 참조하는지, 관계의 종류(1:N, M:N 등).
        
    - **데이터 일관성 규칙:** 예를 들어, 특정 상태 값의 의미, 소프트 삭제 정책 등.
        
    - 이유: PHP 백엔드는 DB를 직접 사용하고, Java 소켓 서버도 채팅 관련 데이터를 DB에 저장/조회하며, 안드로이드 클라이언트는 서버로부터 받는 데이터의 구조를 이해하는 데 필요합니다.
        
3. **PHP 백엔드 API 명세 (OpenAPI 3.0 또는 유사 형식):**
    
    - **모든 엔드포인트 URL 및 HTTP 메소드:** (예: POST /api/v1/auth/login)
        
    - **요청 형식:**
        
        - Path 파라미터, Query 파라미터 (이름, 타입, 필수 여부)
            
        - Request Body 구조 (JSON 스키마, 필드명, 타입, 필수 여부)
            
        - Request Headers (특히 Authorization: Bearer <JWT_TOKEN> 등 인증 관련)
            
    - **응답 형식:**
        
        - 성공/실패 시 HTTP 상태 코드
            
        - Response Body 구조 (JSON 스키마, 필드명, 타입) - 성공 시 데이터 구조, 실패 시 에러 메시지 구조
            
    - **인증 방식:** JWT 토큰 사용 여부, 토큰 획득 및 갱신 방법, 토큰 페이로드 구조 (선택적).
        
    - 이유: 안드로이드 클라이언트는 이 API를 호출해야 하고, Java 소켓 서버도 경우에 따라 (예: 사용자 정보 조회, 토큰 검증 위임 등) 이 API를 호출하거나 참조할 수 있습니다.
        
4. **Java 실시간 소켓 서버 메시지 프로토콜 (JSON 기반):**
    
    - **공통 메시지 구조:** (예: { "action": "...", "payload": {...}, "seq_id": "..." })
        
    - **모든 action 타입 정의:** 클라이언트 -> 서버, 서버 -> 클라이언트 각각의 모든 액션명.
        
    - **각 action별 payload 구조:** JSON 스키마, 필드명, 타입, 필수 여부.
        
    - **인증 방식:** 소켓 연결 후 인증 절차 (예: AUTH 액션과 JWT 토큰).
        
    - **주요 흐름:** 메시지 송수신, 채팅방 참여/퇴장, WebRTC 시그널링 등 주요 기능의 메시지 교환 순서.
        
    - 이유: 안드로이드 클라이언트는 이 프로토콜에 맞춰 소켓 서버와 통신해야 하고, Java 소켓 서버는 이 프로토콜을 구현해야 합니다. PHP 백엔드도 (예: 특정 이벤트 발생 시 소켓 서버에 알림을 보내야 한다면) 이 프로토콜을 알아야 할 수 있습니다.
        
5. **주요 데이터 모델 (DTOs/VOs) 정의:**
    
    - 시스템 전체에서 공통적으로 사용되거나 컴포넌트 간에 주고받는 핵심 데이터 객체의 구조.
        
    - 예: User, Post, Comment, Message, ChatRoom 등의 객체가 어떤 속성(필드명, 타입)을 가지는지.
        
    - 이는 DB 스키마, API 응답, 소켓 메시지 페이로드와 일관성을 가져야 합니다.
        
    - 이유: 각 LLM이 데이터를 동일한 방식으로 이해하고 처리하도록 보장합니다.
        
6. **개발 우선순위 및 MVP(Minimum Viable Product) 정의:**
    
    - 어떤 기능부터 개발해야 하는지, 각 개발 단계(Phase)의 목표는 무엇인지.
        
    - MVP에 포함되는 기능 목록.
        
    - 이유: 각 LLM이 독립적으로 작업하더라도 전체 프로젝트 진행 상황에 맞춰 올바른 순서로 기능을 개발하도록 합니다.
        
7. **공통 개발 지침 및 원칙:**
    
    - TDD 적용 방식 (테스트 코드 작성 스타일, 커버리지 목표 등).
        
    - Git 커밋 메시지 컨벤션.
        
    - 코딩 스타일 가이드 (네이밍 컨벤션, 주석 정책 등).
        
    - 에러 처리 전략 (어떤 종류의 에러를 어떻게 처리하고 로깅할 것인지).
        
    - 이유: 프로젝트 전체의 코드 품질과 일관성을 유지합니다.
        
8. **기술 스택 (선택된 주요 라이브러리 및 프레임워크 버전 포함):**
    
    - 각 컴포넌트에서 사용하기로 결정된 주요 기술, 프레임워크, 라이브러리 및 그 버전.
        
    - 예: Laravel 버전, Netty 버전, Retrofit 버전, Jackson/Gson 등.
        
    - 이유: 호환성 문제를 방지하고, 각 LLM이 올바른 도구를 사용하도록 안내합니다.
        

**이 정보들을 어떻게 LLM에게 효과적으로 전달하고 공유할 것인가?**

- **중앙 집중식 문서:** 위 정보들을 잘 정리된 하나의 "통합 설계 및 개발 계획서" 또는 여러 개의 연관된 문서로 만들어 LLM 프롬프트에 참조하도록 명시합니다. (예: "ASSA - 통합 설계 및 개발 계획서 v1.0 문서를 참조하여...")
    
- **프롬프트 내 명시:** 각 LLM에게 작업을 지시할 때, 해당 작업과 관련된 특정 정보(예: 특정 API 엔드포인트 명세, 특정 소켓 메시지 구조)를 프롬프트에 직접 포함시키거나 명확히 링크합니다.